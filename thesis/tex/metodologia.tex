\label{secao:metodologia}

Neste capítulo, apresentamos a metodologia desenvolvida para a simulação de fumaça em malhas não-estruturadas utilizando o método RBF-FD. A abordagem proposta combina técnicas de simulação de fluidos baseadas no trabalho seminal \emph{Stable Fluids} proposto por \citeonline{Stam1999} com uma nova formulação para lidar com malhas arbitrárias através de funções de base radial, conforme usado por \citeonline{Nakanishi2020}.

Nossa metodologia está estruturada em quatro seções principais. Inicialmente, apresentamos uma adaptação do pipeline de \citeonline{Stam1999} para o contexto de malhas não-estruturadas, detalhando a discretização e resolução de cada termo das Equações de Navier-Stokes utilizando RBF-FD.

A segunda seção introduz uma solução para o problema de intersecção entre raios e polígonos, contribuição fundamental para o tratamento adequado de partículas que ultrapassam os limites do domínio durante a simulação. Esta solução estende as capacidades do método semi-lagrangiano tradicional \cite{Stam1999} para operar em malhas arbitrárias, superando as limitações das abordagens anteriores que se restringiam a malhas estruturadas \cite{Stam2003}.

A terceira seção aborda os desafios específicos relacionados ao uso de malhas não estruturadas. Apresentamos estratégias para melhorar a precisão do método RBF nas fronteiras do domínio, incluindo o desenvolvimento de técnicas especiais para o tratamento de nós fantasma, utilizando o trabalho desenvolvido em \citeonline{FLYER201639}.

Por fim, discutimos os aspectos computacionais da implementação, detalhando as estruturas de dados utilizadas e as otimizações realizadas para garantir a eficiência do método em aplicações práticas.
\section{Pipeline do \emph{Stable Fluids}}
\label{sec:impl_terms}

A implementação numérica das Equações de Navier-Stokes incompressíveis usando o método RBF-FD requer a discretização adequada de cada um dos termos apresentados na Seção~\ref{sec:anim_fumaca}. Nesta seção, detalharemos como cada termo foi implementado, mantendo a consistência com as propriedades matemáticas do escoamento e garantindo a estabilidade numérica da simulação.

\subsection{Termo de Advecção}
\label{subsec:impl_advec}

O termo de advecção, $(\mathbf{u}\cdot\nabla)\mathbf{u}$, representa o transporte das propriedades do fluido pelo próprio campo de velocidades. Para sua implementação usando RBF-FD, adotamos uma abordagem semi-lagrangiana similar à apresentada por Stam~\cite{Stam1999}, porém adaptada ao contexto de malhas não-estruturadas. O procedimento pode ser descrito em três etapas principais:

\begin{description}
    \item[Etapa 1:] Para cada ponto $\mathbf{x}_i$ da malha computacional no tempo $t^n$, calculamos a posição de origem $\mathbf{x}_i^*$ através do \emph{backtracking}:

    \begin{equation}
        \mathbf{x}_i^* = \mathbf{x}_i - \Delta t\mathbf{u}(\mathbf{x}_i, t^n)
        \label{eq:backtrack}
    \end{equation}

    \item[Etapa 2:] Como $\mathbf{x}_i^*$ geralmente não coincide com um ponto da malha, utilizamos interpolação RBF para aproximar o valor da velocidade nesta posição. A função de interpolação é construída usando os $N$ pontos mais próximos de $\mathbf{x}_i^*$, onde $N$ é o número de pontos do estêncil:

    \begin{equation}
        \mathbf{u}(\mathbf{x}_i^*, t^{n-1}) = \sum_{j=1}^N \lambda_j \phi(\|\mathbf{x}_i^* - \mathbf{x}_j\|)
        \label{eq:rbf_interp}
    \end{equation}

    onde $\phi(r)$ é a função de base radial escolhida e $\lambda_j$ são os coeficientes de interpolação determinados pela solução de um sistema linear local.

    \item[Etapa 3:] O valor interpolado é então atribuído ao ponto $\mathbf{x}_i$ no tempo $t^n$:

    \begin{equation}
        \mathbf{u}(\mathbf{x}_i, t^n) = \mathbf{u}(\mathbf{x}_i^*, t^{n-1})
        \label{eq:advec_update}
    \end{equation}
\end{description}

\subsection{Termo do Gradiente de Pressão}
\label{subsec:impl_press}

O termo do gradiente de pressão, $-\frac{1}{\rho}\nabla p$, é implementado diretamente usando os pesos RBF-FD previamente calculados para o operador gradiente. Para um ponto $\mathbf{x}_i$ e seu estêncil de $N$ pontos, temos:

\begin{equation}
    (\nabla p)_i = \sum_{j=1}^N \omega_{ij}^{\nabla} p_j
    \label{eq:press_grad}
\end{equation}

\noindent onde $\omega_{ij}^{\nabla}$ são os pesos RBF-FD para o operador gradiente.
\subsection{Termo de Força Externa}
\label{subsec:impl_force}

O termo de força externa $\mathbf{g}$ incorpora as forças volumétricas que atuam sobre o fluido, como a gravidade e forças de interação do usuário. No contexto da simulação de fumaça, este termo é particularmente importante para modelar o efeito de empuxo térmico. A implementação deste termo é direta, sendo adicionado explicitamente ao campo de velocidades:

\begin{equation}
    \mathbf{u}^{n+1} = \mathbf{u}^n + \Delta t\mathbf{g}
    \label{eq:force_update}
\end{equation}

Para o caso específico da força de empuxo térmico, utilizamos a aproximação de Boussinesq:

\begin{equation}
    \mathbf{g} = \beta(T - T_{\infty})\mathbf{g}_0
    \label{eq:buoyancy}
\end{equation}

\noindent onde $\beta$ é o coeficiente de expansão térmica, $T$ é a temperatura local, $T_{\infty}$ é a temperatura ambiente e $\mathbf{g}_0$ é o vetor da aceleração da gravidade.

\subsection{Projeção do Campo de Velocidades}
\label{subsec:impl_proj}

A etapa de projeção é fundamental para garantir a condição de incompressibilidade do fluido ($\nabla\cdot\mathbf{u}=0$). Seguindo a decomposição de Helmholtz-Hodge apresentada na Seção~\ref{sec:anim_fumaca}, implementamos a projeção em três etapas:

Primeiro, calculamos o divergente do campo de velocidades intermediário $\mathbf{w}$ usando os pesos RBF-FD para o operador divergente:

\begin{equation}
    (\nabla\cdot\mathbf{w})_i = \sum_{j=1}^N \omega_{ij}^{\mathrm{div}} \cdot \mathbf{w}_j
    \label{eq:div_calc}
\end{equation}

Em seguida, resolvemos a equação de Poisson para a pressão:

\begin{equation}
    \nabla^2 p = \nabla\cdot\mathbf{w}
    \label{eq:poisson_discrete}
\end{equation}

\noindent utilizando os pesos RBF-FD para o operador Laplaciano, resulta no sistema linear:

\begin{equation}
    \sum_{j=1}^N \omega_{ij}^L p_j = (\nabla\cdot\mathbf{w})_i
    \label{eq:poisson_system}
\end{equation}

Para este sistema, aplicamos a condição de contorno de Neumann na fronteira do domínio:

\begin{equation}
    \nabla p \cdot \mathbf{n} = 0
    \label{eq:neumann_bc}
\end{equation}

Por fim, o campo de velocidades livre de divergência é obtido subtraindo o gradiente de pressão do campo intermediário:

\begin{equation}
    \mathbf{u}_i = \mathbf{w}_i - \nabla p_i
    \label{eq:proj_final}
\end{equation}

\noindent onde $\nabla p_i$ é calculado usando a Equação~\eqref{eq:press_grad}.

\subsection{Algoritmo Completo}
\label{subsec:impl_alg}

\begin{figure}
    \centering
    \caption{Fluxograma do pipeline de simulação de fluidos.}
    \includegraphics[width=0.8\textwidth]{images/pipeline.pdf}
    \subcaption*{Fonte: Elaborada pelo autor.}
    \label{fig:pipeline}
\end{figure}

O algoritmo completo para a simulação do escoamento, ilustrado na \figref{fig:pipeline}, pode ser resumido nas seguintes etapas:

\begin{enumerate}
    \item Atualização das forças externas usando as Equações~\eqref{eq:force_update} e~\eqref{eq:buoyancy};
    \item Advecção do campo de velocidades através das Equações~\eqref{eq:backtrack}--\eqref{eq:advec_update};
    \item Projeção do campo para garantir a incompressibilidade usando as Equações~\eqref{eq:div_calc}--\eqref{eq:proj_final}.
\end{enumerate}

Este procedimento é repetido a cada passo de tempo da simulação, garantindo a evolução estável e fisicamente consistente do escoamento.


\section{Interseção com a Fronteira}
\label{sec:interseccao_fronteira}

Durante o processo de advecção semi-lagrangiana descrito na Etapa 1 da Seção~\ref{subsec:impl_advec}, o \emph{backtracking} a partir de um ponto $\mathbf{x}_i$ pode resultar em uma posição $\mathbf{x}_i^*$ que se encontra fora do domínio computacional. Este cenário é particularmente comum em malhas não-estruturadas com fronteiras complexas, onde partículas próximas aos contornos podem, ao serem advectadas, ultrapassar os limites do domínio. Para garantir que a interpolação seja realizada corretamente e que as condições de contorno sejam respeitadas, é fundamental determinar com precisão onde o raio de \emph{backtracking} intersecta a fronteira da malha.

A solução deste problema requer o cálculo eficiente da interseção entre um raio (definido pela trajetória de \emph{backtracking}) e os segmentos que compõem a fronteira do polígono que delimita o domínio computacional. Um algoritmo amplamente utilizado para calcular essa interseção baseia-se no método de \emph{Ray Casting} (lançamento de raio), que consiste em disparar um raio a partir de um ponto de origem na direção desejada e determinar onde ele cruza as arestas do polígono. O algoritmo examina cada aresta do polígono para verificar se ocorre uma interseção com o raio, determinando o ponto exato onde essa interseção acontece.

\subsection{Algoritmo}
Para calcular a interseção entre um raio e um polígono em 2D, focamos apenas na interseção do raio com as arestas do polígono. Um método eficaz para isso é o algoritmo de interseção de segmento de linha, como o algoritmo de Cohen-Sutherland ou o algoritmo de Liang-Barsky \cite{foley1996computer}. Vamos considerar o algoritmo de Cohen-Sutherland, que é mais simples de entender e implementar para esse cenário específico.

Para cada aresta do polígono, representada pelos pontos $P_1$ e $P_2$, calculamos a interseção com o raio utilizando a equação paramétrica da reta. Sejam $P_1(x_1,y_1)$ e $P_2(x_2,y_2)$ os pontos que definem a aresta e $(x,y)$ o ponto de interseção com o raio. A equação paramétrica da reta é dada por:

\begin{align}
x=x_1+t(x_2-x_1)\\
y=y_1+t(y_2-y_1)
\end{align}

\noindent onde $t$ é um parâmetro que varia de 0 a 1. Substituindo essas equações na equação do raio, obtemos uma equação:
\begin{equation}
t=(x-x_1)(x_2-x_1)=(y-y_1)(y_2-y_1)
\end{equation}

Se $t$ estiver no intervalo [0, 1], então a interseção ocorre dentro do segmento de linha $P_1P_2$. Calculando $t$ para ambos os eixos, podemos verificar se o ponto de interseção está dentro do segmento de linha.

Este procedimento é repetido para cada aresta do polígono. Se houver interseção, o algoritmo retorna o ponto de interseção mais próximo ao ponto de origem do raio. Se não houver interseção com nenhuma das arestas, então o raio não intersecta o polígono.

Este algoritmo é simples de implementar em 2D, fornecendo uma solução robusta para calcular a interseção entre um raio e um polígono.

\begin{figure}[H]
    \centering
    \caption{Exemplo de interseção entre raio de \emph{backtracking} e fronteira do domínio. A malha é representada em azul, $P_1$ é o ponto de origem (vermelho) do raio, a direção do raio é indicada pela seta vermelha, $P_2$ é o ponto final (preto), e o ponto de interseção com a fronteira é mostrado em verde.}
    \includegraphics[width=0.8\textwidth]{images/intersect.pdf}
    \subcaption*{Fonte: Elaborada pelo autor.}
    \label{fig:intersect}
\end{figure}

\subsection{Desempenho}
É possível aplicar uma vetorização a esse cálculo para tentar melhorar o desempenho, fazendo com que seja calculada a interseção de um raio com todas as arestas de um polígono em um único passo. A técnica de vetorização permite uma abordagem eficiente e paralela para calcular a interseção de um raio com múltiplas arestas de um polígono em 2D, proporcionando uma solução escalável e otimizada para esse problema.

Embora a técnica de vetorização ofereça uma abordagem eficiente para calcular a interseção de um raio com múltiplas arestas de um polígono em 2D, implementá-la diretamente em Python pode resultar em um desempenho insatisfatório para conjuntos de dados maiores. Isso ocorre devido à natureza interpretada do Python e à falta de otimização de baixo nível para operações matriciais.

Para superar essa limitação de desempenho, podemos recorrer à técnica de compilação just-in-time (JIT) oferecida pela biblioteca Numba\footnote{\url{https://numba.pydata.org/}}. Numba é uma biblioteca que compila funções Python em código de máquina otimizado, melhorando significativamente o desempenho, especialmente para operações numéricas intensivas.

Ao utilizar Numba, podemos decorar a função que calcula a interseção do raio com múltiplas arestas com \texttt{@jit} para permitir a compilação JIT. Isso transformará a função em código de máquina otimizado, proporcionando uma melhoria significativa no desempenho.

Além disso, ao trabalhar com grandes conjuntos de dados, podemos aproveitar técnicas de paralelismo oferecidas por Numba para distribuir as operações em múltiplos núcleos de CPU, acelerando ainda mais o processo de cálculo.

Portanto, ao utilizar Numba, podemos melhorar significativamente o desempenho do algoritmo de cálculo da interseção do raio com múltiplas arestas, tornando-o adequado para lidar eficientemente com conjuntos de dados maiores em tempo real ou aplicações de alto desempenho.

\subsection{Interpolação}

Durante o processo de \emph{backtracking}, quando a posição $\mathbf{x}_i^*$ não coincide com um ponto da malha, é necessário interpolar os valores das propriedades do fluido a partir dos pontos vizinhos. Nas malhas triangulares, dois métodos comuns de interpolação são utilizados: baricêntrica e RBF (Radial Basis Function). O método de interpolação baricêntrica é uma abordagem direta que interpola valores dentro de cada elemento triangular usando uma combinação linear dos valores conhecidos nos vértices do triângulo. Por outro lado, o método RBF utiliza funções de base radial para interpolar os valores, permitindo uma maior flexibilidade na representação de dados irregulares.

No entanto, embora o método RBF ofereça essa flexibilidade, ele é conhecido por sofrer de baixa precisão perto das bordas dos elementos triangulares. Essa baixa precisão é atribuída à maneira como as funções de base radial são distribuídas, resultando em uma interpolação menos confiável em regiões próximas às fronteiras. Como consequência, a interpolação RBF pode gerar campos que não são divergentes nulos, o que significa que as propriedades físicas não estão sendo corretamente representadas, criando artefatos na simulação. Esses artefatos podem distorcer os resultados da simulação e comprometer a precisão do modelo, especialmente em problemas onde a conservação de massa e outras leis físicas são críticas.

Além disso, exploramos a influência dos métodos de interpolação do \emph{backtracking} na simulação, comparando os resultados obtidos com os métodos baricêntrico e RBF, visando identificar as diferenças de desempenho e suas implicações na precisão das previsões de dispersão de fumaça.

\section{Malhas arbitrárias}

Para criar malhas triangulares arbitrárias, aproveitamos uma biblioteca de malhas de países, que fornece uma representação precisa das fronteiras de países. Essa biblioteca permite gerar malhas de alta resolução para uma variedade de regiões geográficas, oferecendo uma base sólida para a simulação de dispersão de fumaça em diferentes ambientes. É importante destacar que as malhas de países são descritas apenas pelas fronteiras, sem uma triangulação prévia. Para realizar a triangulação das fronteiras e obter as malhas triangulares necessárias para a simulação, utilizamos um wrapper Python da biblioteca Triangle~\cite{triangle}, uma ferramenta conhecida por sua capacidade de realizar triangulações de Delaunay com restrições de maneira eficiente e robusta. Vale ressaltar que a triangulação pode gerar malhas com características que dificultam a solução de problemas de interpolação, especialmente quando utilizamos métodos baseados em RBF (Radial Basis Function). Essas malhas complexas podem apresentar regiões onde a solução do problema de RBF se torna instável ou até mesmo impossível de ser determinada devido à natureza irregular da malha.

\subsection{Precisão do RBF}

Observamos resultados mais precisos em malhas com topologia convexa e sem uma densidade de vértices alta na fronteira, pois, na solução de problemas por interpolação por funções de base radial (RBF), a proximidade entre vértices pode gerar problemas na obtenção de resultados precisos. Isso se deve à maneira como os pesos da função de interpolação são calculados. A função RBF utiliza uma operação que eleva a distância entre os vértices a um expoente para determinar a influência de cada ponto na interpolação.
Essa operação pode levar à instabilidade na solução quando os vértices estão muito próximos uns dos outros. Em casos de extrema proximidade entre vértices, a matriz de coeficientes do sistema linear a ser solucionado torna-se mal condicionada. Isso significa que a solução pode ser altamente sensível a pequenas alterações nos dados, resultando em resultados imprecisos e oscilações indesejáveis na função interpolada.


\section{Tratamento de Fronteiras}
\label{sec:fronteiras}

O tratamento adequado das fronteiras é essencial para manter a precisão e estabilidade do método RBF-FD em malhas não-estruturadas. Nossa abordagem para o tratamento de fronteiras representa uma simplificação significativa da proposta por \citeonline{FLYER201639}, mantendo as vantagens de precisão enquanto reduz a complexidade computacional. Nesta seção, apresentamos inicialmente o método tradicional de \emph{collocation} e suas limitações, seguido pela técnica de nós fantasma e a formulação matemática completa para sua aplicação na solução da equação de Poisson.

\subsection{Método de Collocation para Condições de Neumann}
\label{subsec:collocation}

A imposição de condições de contorno de Neumann na resolução da equação de Poisson pode ser realizada através do método de \emph{collocation}. Este método substitui a equação diferencial nos nós de fronteira pela equação da condição de contorno, resultando em um sistema linear que incorpora automaticamente as restrições de fronteira.

\begin{figure}[H]
    \centering
    \caption{Exemplo de malha para método de \emph{collocation}. Os nós 1, 2, 3 e 4 (azul ciano) estão na fronteira com vetores normais $\mathbf{n}$ apontando para fora, e o nó 5 (laranja) é interno.}
    \includegraphics[width=0.5\textwidth]{images/collocation_mesh.pdf}
    \subcaption*{Fonte: Elaborada pelo autor.}
    \label{fig:collocation_example}
\end{figure}

Para ilustrar este conceito, considere um domínio simples com 5 nós, conforme mostrado na \figref{fig:collocation_example}, onde os nós 1, 2, 3 e 4 estão na fronteira e o nó 5 é interno. A equação de Poisson $\nabla^2 p = \nabla\cdot\mathbf{u}$, onde $\mathbf{u}$ é o campo vetorial, vamos simplificar e usar $\nabla\cdot\mathbf{u} = b$, deve ser satisfeita em todos os nós, enquanto a condição de Neumann $\frac{\partial p}{\partial \mathbf{n}} = 0$ deve ser imposta nos nós de fronteira.

No método RBF-FD, a aproximação dos operadores diferenciais em um nó $\mathbf{x}_i$ utiliza um conjunto de nós vizinhos, denominado estêncil e denotado por $\mathcal{S}_i = \{\mathbf{x}_j\}_{j=1}^{N_i}$, onde $N_i$ é o número de pontos no estêncil do nó $i$. Utilizando este conjunto de vizinhos, a derivada normal pode ser aproximada por:

\begin{equation}
   \frac{\partial p}{\partial \mathbf{n}} = \nabla p \cdot \mathbf{n} \approx \sum_{j \in \mathcal{S}_i} \omega_j^n p_j = 0
   \label{eq:neumann_collocation}
\end{equation}

\noindent onde os pesos da derivada normal são dados por $\omega_j^n = n_x \omega_j^x + n_y \omega_j^y$, sendo $\omega_j^x$ e $\omega_j^y$ os pesos RBF-FD para as derivadas parciais e $\mathbf{n} = (n_x, n_y)$ o vetor normal unitário à fronteira.

O sistema linear resultante combina as equações do Laplaciano para os nós internos com as equações de Neumann para os nós de fronteira:

\begin{equation}
\begin{bmatrix}
\omega_1^n & \omega_2^n & 0 & \omega_4^n & \omega_5^n \\
\omega_1^n & \omega_2^n & \omega_3^n & 0 & \omega_5^n \\
0 & \omega_2^n & \omega_3^n & \omega_4^n & \omega_5^n \\
\omega_1^n & 0 & \omega_3^n & \omega_4^n & \omega_5^n \\
\omega_1^L & \omega_2^L & \omega_3^L & \omega_4^L & \omega_5^L
\end{bmatrix}
\begin{bmatrix}
p_1 \\ p_2 \\ p_3 \\ p_4 \\ p_5
\end{bmatrix}
=
\begin{bmatrix}
0 \\ 0 \\ 0 \\ 0 \\ b_5
\end{bmatrix}
\label{eq:collocation_system}
\end{equation}

As primeiras quatro linhas correspondem às condições de Neumann nos nós de fronteira (1, 2, 3 e 4), enquanto a última linha corresponde à equação de Poisson no nó interno (5). Este sistema pode ser resolvido diretamente para obter os valores de pressão que satisfazem simultaneamente a equação de Poisson no interior do domínio e a condição de Neumann na fronteira.

Embora o método de \emph{collocation} seja conceitualmente simples e direto, ele apresenta limitações importantes em termos de precisão. O problema fundamental está na assimetria dos estêncils próximos à fronteira. No exemplo da \figref{fig:collocation_example}, observe que o nó 1, localizado no canto superior esquerdo, possui vizinhos apenas nas direções para baixo e para a direita. Esta distribuição assimétrica de pontos no estêncil prejudica a qualidade da aproximação RBF-FD dos operadores diferenciais, resultando em erros maiores para nós de fronteira quando comparados aos nós internos.

Para ilustrar esta limitação, considere o cálculo do Laplaciano $\nabla^2 p$ no nó 1. O estêncil para este nó contém apenas os nós 2, 4 e 5, todos localizados em um mesmo semiplano em relação ao nó 1. Esta configuração unilateral dificulta a captura precisa do comportamento da função em todas as direções, especialmente na direção normal à fronteira, onde não há nós disponíveis para balancear o estêncil. Este problema se agrava em malhas não-estruturadas com geometrias complexas, onde a distribuição irregular de nós amplifica a assimetria dos estêncils de fronteira.

Estas limitações motivam a busca por técnicas alternativas que possam melhorar a precisão das aproximações em nós de fronteira, mantendo a estrutura geral do método RBF-FD. A seguir, apresentamos a técnica de nós fantasma, que oferece uma solução elegante para este problema.

\subsection{Nós Fantasmas}
\label{subsec:ghost_temp}

A técnica de nós fantasma foi desenvolvida especificamente para superar as limitações do método de \emph{collocation} descritas anteriormente. A ideia central é balancear artificialmente os estêncis assimétricos de fronteira através da adição temporária de nós virtuais fora do domínio computacional. Estes nós fantasma são posicionados estrategicamente para simetrizar o estêncil, melhorando significativamente a precisão das aproximações RBF-FD em nós de fronteira.

A \figref{fig:ghost_node} ilustra o conceito de nó fantasma em uma malha triangular. O nó de fronteira destacado $\mathbf{x}_b$ (em vermelho) está localizado na fronteira superior do domínio. O nó fantasma $\mathbf{x}_g$ (em azul tracejado) é criado fora do domínio, na direção do vetor normal $\mathbf{n}$, a uma distância $h$ controlada pelo parâmetro $\alpha$.

Para cada nó da fronteira $\mathbf{x}_b$, criamos um nó fantasma $\mathbf{x}_g$ na direção normal à fronteira:

\begin{equation}
   \mathbf{x}_g = \mathbf{x}_b + h\mathbf{n}
   \label{eq:ghost_position}
\end{equation}

\noindent onde $\mathbf{n}$ é o vetor normal unitário à fronteira no nó $\mathbf{x}_b$ e $h$ é a distância do nó fantasma, definida como:

\begin{equation}
   h = \alpha \cdot \Delta x_{local}
   \label{eq:ghost_distance}
\end{equation}

\noindent onde $\Delta x_{local}$ é uma medida do espaçamento local da malha e $\alpha$ é um parâmetro de ajuste que controla a influência do nó fantasma.

\begin{figure}
    \centering
    \caption{Ilustração da criação de um nó fantasma para tratamento de fronteiras. O nó fantasma $\mathbf{x}_g$ é criado na direção normal $\mathbf{n}$ a partir do nó de fronteira $\mathbf{x}_b$, a uma distância $h$.}
    \includegraphics[width=0.6\textwidth]{images/ghost_node.pdf}
    \subcaption*{Fonte: Elaborada pelo autor.}
    \label{fig:ghost_node}
\end{figure}

\subsection{Simplificação da Abordagem de Flyer et al.}
\label{subsec:simplification}

Embora a técnica de nós fantasma seja promissora, diferentes abordagens para sua implementação podem resultar em complexidades computacionais distintas. A abordagem proposta por \citeonline{FLYER201639} para o tratamento de fronteiras com nós fantasma é bastante sofisticada, envolvendo a reflexão de todos os nós internos através da fronteira e a criação de múltiplos nós fantasma. Neste método completo, cada nó de fronteira possui diversos nós fantasma em seu estêncil, oriundos das reflexões de seus vizinhos internos. Esta estratégia resulta em estêncils altamente balanceados e precisão elevada, mas requer a solução de sistemas lineares adicionais para cada configuração de estêncil.

Nossa implementação adota uma simplificação substancial desta abordagem: para cada nó de fronteira, criamos apenas \emph{um único nó fantasma temporário} na direção normal, conforme ilustrado na \figref{fig:ghost_node}. Esta simplificação traz vantagens computacionais significativas em diversos aspectos.

Primeiramente, em termos de eficiência computacional, evita-se a necessidade de resolver sistemas lineares adicionais para determinar os valores nos múltiplos nós fantasma, como requerido na abordagem completa de \citeonline{FLYER201639}. A criação de um único nó fantasma por nó de fronteira também resulta em código mais simples e manutenível, facilitando a implementação e depuração do método. Do ponto de vista de uso de memória, não é necessário armazenar as posições e relações de múltiplos nós fantasma refletidos, reduzindo significativamente os requisitos de armazenamento.

A vantagem mais relevante para a simulação de fluidos está na resolução direta do Laplaciano. Para resolver a equação de Poisson na etapa de projeção, necessitamos apenas dos pesos do operador Laplaciano. Com a simplificação proposta, estes pesos são obtidos diretamente através de uma formulação matemática que combina os pesos padrão do Laplaciano com uma correção baseada na condição de Neumann, conforme será detalhado na próxima subseção.

Esta simplificação é particularmente vantajosa para o problema de simulação de fluidos, onde a equação de Poisson deve ser resolvida a cada passo de tempo. Na prática, construímos a matriz esparsa do Laplaciano uma única vez durante a inicialização, utilizando pesos modificados para os nós de fronteira e pesos padrão RBF-FD para os nós internos. Durante a simulação, a resolução da equação de Poisson reduz-se à multiplicação desta matriz pelos valores de divergência e à solução do sistema linear resultante.

Embora a abordagem simplificada possa resultar em precisão ligeiramente inferior à do método completo de \citeonline{FLYER201639} em problemas gerais, ela se mostra adequada para a simulação de fluidos incompressíveis, onde a ênfase está na conservação de massa e na estabilidade da simulação. A próxima subseção detalha os aspectos matemáticos do cálculo dos pesos RBF-FD com nós fantasma.

\subsection{Cálculo do Laplaciano com Nós Fantasmas}
\label{subsec:ghost_weights}

A presença do nó fantasma no estêncil de fronteira afeta especificamente o cálculo do operador Laplaciano. O método RBF-FD para calcular os pesos permanece inalterado; a única modificação é a inclusão temporária do nó fantasma $\mathbf{x}_g$ no estêncil durante o cálculo. O que diferencia esta abordagem é o tratamento subsequente destes pesos para incorporar a condição de contorno de Neumann e eliminar a dependência do nó fantasma.

\subsubsection{Pesos RBF-FD com estêncil Estendido}

Considere um nó de fronteira $\mathbf{x}_b$ com seu estêncil original $\mathcal{S} = \{\mathbf{x}_1, \mathbf{x}_2, \ldots, \mathbf{x}_N\}$. Ao incluir o nó fantasma $\mathbf{x}_g$ no estêncil, formamos o estêncil estendido $\mathcal{S}_g = \mathcal{S} \cup \{\mathbf{x}_g\}$. Os pesos RBF-FD para os operadores derivadas direcionais ($\partial_x$ e $\partial_y$) e Laplaciano são calculados da mesma forma que para nós internos, resolvendo o sistema linear local definido no capítulo anterior. A diferença é que agora obtemos pesos adicionais correspondentes ao nó fantasma.

Com o estêncil estendido, o operador Laplaciano é aproximado por:

\begin{equation}
   \nabla^2 u(\mathbf{x}_b) \approx \sum_{j=1}^N \omega_j^L u_j + \omega_g^L u_g
   \label{eq:laplacian_with_ghost}
\end{equation}

\noindent onde $u_j = u(\mathbf{x}_j)$ são os valores da função nos nós do estêncil, $u_g = u(\mathbf{x}_g)$ é o valor no nó fantasma, e $\omega_j^L$ e $\omega_g^L$ são os pesos RBF-FD calculados normalmente com o estêncil estendido. Da mesma forma, obtemos pesos para as derivadas parciais: $\omega_j^x$, $\omega_g^x$, $\omega_j^y$ e $\omega_g^y$.

Como o nó fantasma não faz parte do domínio original e não possui valores físicos associados, é necessário eliminar a dependência de $u_g$ na expressão acima. Esta eliminação é realizada através da condição de contorno de Neumann, conforme descrito a seguir.

\subsubsection{Aplicação da Condição de Neumann}

A condição de contorno de Neumann homogênea, utilizada na etapa de projeção da Equação~\eqref{eq:neumann_bc}, pode ser expressa como:

\begin{equation}
   \frac{\partial u}{\partial \mathbf{n}} = \nabla u \cdot \mathbf{n} = 0 \quad \text{em } \mathbf{x}_b
   \label{eq:neumann_condition}
\end{equation}

Utilizando RBF-FD para aproximar o gradiente, temos:

\begin{equation}
   \nabla u(\mathbf{x}_b) \cdot \mathbf{n} \approx \sum_{j=1}^N \omega_j^n u_j + \omega_g^n u_g = 0
   \label{eq:neumann_rbffd}
\end{equation}

\noindent onde os pesos da derivada normal são dados por:

\begin{equation}
   \omega_j^n = n_x \omega_j^x + n_y \omega_j^y
   \label{eq:normal_weights}
\end{equation}

\noindent sendo $\omega_j^x$ e $\omega_j^y$ os pesos RBF-FD para as derivadas parciais em $x$ e $y$, respectivamente, e $\mathbf{n} = (n_x, n_y)$ o vetor normal unitário à fronteira.

Com a condição de Neumann estabelecida, podemos agora expressar o valor do nó fantasma $u_g$ em termos dos valores conhecidos nos nós do domínio e, consequentemente, eliminar sua dependência na aproximação do Laplaciano.

\subsubsection{Eliminação do Nó Fantasma e Pesos Efetivos}

O passo fundamental que modifica o cálculo do Laplaciano em nós de fronteira é a eliminação da dependência do valor no nó fantasma $u_g$. Como $u_g$ não faz parte do domínio original, precisamos expressá-lo em termos dos valores conhecidos nos nós do domínio. Isso é feito através da condição de Neumann.

Da Equação~\eqref{eq:neumann_rbffd}, podemos isolar o valor da função no nó fantasma:

\begin{equation}
   u_g = -\frac{1}{\omega_g^n} \sum_{j=1}^N \omega_j^n u_j
   \label{eq:ghost_value}
\end{equation}

Substituindo a Equação~\eqref{eq:ghost_value} na Equação~\eqref{eq:laplacian_with_ghost}, realizamos a eliminação do nó fantasma:

\begin{align}
   \nabla^2 u(\mathbf{x}_b) &\approx \sum_{j=1}^N \omega_j^L u_j + \omega_g^L u_g \nonumber \\
   &= \sum_{j=1}^N \omega_j^L u_j + \omega_g^L \left( -\frac{1}{\omega_g^n} \sum_{j=1}^N \omega_j^n u_j \right) \nonumber \\
   &= \sum_{j=1}^N \omega_j^L u_j - \frac{\omega_g^L}{\omega_g^n} \sum_{j=1}^N \omega_j^n u_j \nonumber \\
   &= \sum_{j=1}^N \left( \omega_j^L - \frac{\omega_g^L}{\omega_g^n} \omega_j^n \right) u_j \nonumber \\
   &= \sum_{j=1}^N \tilde{\omega}_j^L u_j
   \label{eq:effective_weights}
\end{align}

\noindent onde os pesos efetivos do Laplaciano são:

\begin{equation}
   \tilde{\omega}_j^L = \omega_j^L - \frac{\omega_g^L}{\omega_g^n} \omega_j^n
   \label{eq:final_weights}
\end{equation}

Esta é a fórmula central para o cálculo do Laplaciano em nós de fronteira. Os pesos efetivos $\tilde{\omega}_j^L$ combinam os pesos padrão do Laplaciano $\omega_j^L$ com uma correção baseada nos pesos da derivada normal. Esta correção, dada pelo termo $-\frac{\omega_g^L}{\omega_g^n} \omega_j^n$, incorpora automaticamente a condição de contorno de Neumann e elimina completamente a dependência do nó fantasma. O resultado são pesos que envolvem apenas os nós do domínio original, mas fornecem aproximações mais precisas do Laplaciano em nós de fronteira devido ao balanceamento do estêncil proporcionado pelo ghost node.

Com os pesos efetivos definidos, podemos agora descrever como eles são utilizados na prática para construir o sistema linear global que resolve a equação de Poisson na etapa de projeção.

\subsubsection{Construção da Matriz do Laplaciano}

Na prática computacional, a matriz esparsa do operador Laplaciano é construída uma única vez durante a fase de inicialização da simulação. Para cada nó $i$ do domínio, a linha $i$ da matriz contém os pesos do Laplaciano calculados de acordo com a posição do nó:

\begin{equation}
   L_{ij} = \begin{cases}
      \tilde{\omega}_j^L & \text{se } i \text{ é nó de fronteira (usando Equação~\eqref{eq:final_weights})} \\
      \omega_j^L & \text{se } i \text{ é nó interno (pesos RBF-FD padrão)}
   \end{cases}
   \label{eq:laplacian_matrix}
\end{equation}

Esta matriz $L$ é então utilizada diretamente na resolução da equação de Poisson durante a etapa de projeção. A cada passo de tempo da simulação, a equação $\nabla^2 p = \nabla \cdot \mathbf{w}$ é resolvida através do sistema linear $L\mathbf{p} = \mathbf{b}$, onde $\mathbf{b}$ contém os valores de divergência calculados em cada nó e $\mathbf{p}$ é o vetor de pressões a ser determinado. A condição de Neumann nas fronteiras já está automaticamente incorporada nos pesos efetivos $\tilde{\omega}_j^L$, não sendo necessário tratamento adicional das condições de contorno.

Os pesos $\tilde{\omega}_j^L$ resultantes deste processo são pré-calculados e armazenados para todos os nós de fronteira, sendo reutilizados durante toda a simulação sem necessidade de recálculo a cada passo de tempo. Esta estratégia garante eficiência computacional, uma vez que o custo de calcular os pesos com ghost nodes é pago apenas uma vez na inicialização.

A formulação matemática apresentada nesta seção define completamente o tratamento de fronteiras no método RBF-FD. A próxima seção aborda os aspectos práticos da implementação computacional, incluindo as estruturas de dados utilizadas e as otimizações realizadas para garantir eficiência na simulação.

\section{Aspectos Computacionais}
\label{sec:aspectos_comp}

A implementação do método proposto envolveu diversas decisões de projeto visando balancear eficiência computacional com facilidade de desenvolvimento e manutenção. Python foi escolhido como linguagem principal devido à sua versatilidade e rico ecossistema de bibliotecas científicas, embora uma implementação em C++ pudesse oferecer melhor performance.

\subsection{Otimização de Desempenho}
\label{subsec:optimization}

Para mitigar as limitações de desempenho do Python em operações numéricas intensivas, utilizamos a biblioteca Numba para compilação just-in-time (JIT) em pontos críticos do código. Em particular, o algoritmo de intersecção raio-polígono foi otimizado através desta técnica, resultando em uma aceleração significativa no processo de backtracking, essencial para a advecção semi-lagrangiana.

A compilação JIT permite que segmentos críticos do código sejam convertidos em código de máquina otimizado durante a execução, aproximando o desempenho de linguagens compiladas como C++. Esta otimização foi particularmente efetiva nas operações de intersecção geométrica e interpolação, que são executadas intensivamente durante a simulação.

\subsection{Visualização}
\label{subsec:visualization}

A visualização da simulação foi implementada utilizando OpenGL, com uma abordagem direta onde cada vértice da malha é colorido de acordo com a densidade local do fluido. Esta escolha permite uma renderização eficiente em tempo real, essencial para aplicações interativas e validação visual dos resultados.

O sistema de renderização foi projetado para minimizar transferências de dados entre CPU e GPU, mantendo na memória da placa gráfica apenas as informações necessárias para a visualização. A densidade do fluido é mapeada para uma escala de cores que permite a visualização clara das estruturas do escoamento.

\subsection{Geração de Malhas}
\label{subsec:mesh_generation}

A geração de malhas triangulares a partir de contornos de países foi realizada utilizando a biblioteca Triangle~\cite{triangle}, que implementa o algoritmo de triangulação de Delaunay com restrições. Essa biblioteca foi escolhida por sua robustez e capacidade de lidar com geometrias complexas. A abordagem permite a construção confiável de malhas computacionais a partir de dados geográficos que originalmente continham apenas informações de contorno.

O processo de geração de malha inclui etapas de pré-processamento para garantir a qualidade dos elementos gerados. Inicialmente, realiza-se a verificação e correção de auto-intersecções nos contornos de entrada. Em seguida, aplica-se refinamento adaptativo baseado na curvatura local, garantindo maior densidade de elementos em regiões de geometria complexa. Por fim, executa-se a suavização dos elementos para melhorar a qualidade geral da malha, otimizando aspectos como razão de aspecto e ângulos internos dos triângulos.

\subsection{Estruturas de Dados}
\label{subsec:data_structures}

A implementação utiliza estruturas de dados otimizadas para operações comuns em simulações de fluidos. As propriedades do fluido, como densidade, velocidade e pressão, são armazenadas em arrays contíguos em memória, maximizando a eficiência de acesso e permitindo operações vetorizadas. As matrizes de diferenciação RBF-FD são representadas por estruturas esparsas, explorando o fato de que cada linha contém apenas um número pequeno de entradas não-nulas correspondentes ao estêncil local. Para operações de vizinhança, como a busca dos $k$ vizinhos mais próximos durante a interpolação, utilizam-se árvores de busca espacial que reduzem a complexidade computacional destas operações.

Estas escolhas de implementação permitem um equilíbrio entre facilidade de desenvolvimento e desempenho computacional, resultando em um sistema capaz de simular escoamentos de fumaça em malhas não-estruturadas com eficiência satisfatória para aplicações práticas.